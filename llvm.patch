diff --git a/lib/CodeGen/AsmPrinter/AsmPrinter.cpp b/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
index d74a703..1831bb6 100644
--- a/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
+++ b/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
@@ -173,7 +173,7 @@ bool AsmPrinter::doInitialization(Module &M) {
   for (GCModuleInfo::iterator I = MI->begin(), E = MI->end(); I != E; ++I)
     if (GCMetadataPrinter *MP = GetOrCreateGCPrinter(*I))
       MP->beginAssembly(*this);
-
+/*
   // Emit module-level inline asm if it exists.
   if (!M.getModuleInlineAsm().empty()) {
     OutStreamer.AddComment("Start of file scope inline assembly");
@@ -182,7 +182,7 @@ bool AsmPrinter::doInitialization(Module &M) {
     OutStreamer.AddComment("End of file scope inline assembly");
     OutStreamer.AddBlankLine();
   }
-
+*/
   if (MAI->doesSupportDebugInformation())
     DD = new DwarfDebug(this, &M);
 
@@ -929,6 +929,15 @@ bool AsmPrinter::doFinalization(Module &M) {
     if (GCMetadataPrinter *MP = GetOrCreateGCPrinter(*--I))
       MP->finishAssembly(*this);
 
+  // Emit module-level inline asm if it exists.
+  if (!M.getModuleInlineAsm().empty()) {
+    OutStreamer.AddComment("Start of file scope inline assembly");
+    OutStreamer.AddBlankLine();
+    EmitInlineAsm(M.getModuleInlineAsm()+"\n");
+    OutStreamer.AddComment("End of file scope inline assembly");
+    OutStreamer.AddBlankLine();
+  }
+
   // If we don't have any trampolines, then we don't require stack memory
   // to be executable. Some targets have a directive to declare this.
   Function *InitTrampolineIntrinsic = M.getFunction("llvm.init.trampoline");
diff --git a/lib/Target/CppBackend/CPPBackend.cpp b/lib/Target/CppBackend/CPPBackend.cpp
index 0f3efd8..d96a258 100644
--- a/lib/Target/CppBackend/CPPBackend.cpp
+++ b/lib/Target/CppBackend/CPPBackend.cpp
@@ -375,6 +375,7 @@ std::string CppWriter::getCppName(Type* Ty) {
     case Type::DoubleTyID:   return "Type::getDoubleTy(mod->getContext())";
     case Type::LabelTyID:    return "Type::getLabelTy(mod->getContext())";
     case Type::X86_MMXTyID:  return "Type::getX86_MMXTy(mod->getContext())";
+    case Type::MetadataTyID: return "Type::getMetadataTy(mod->getContext())";
     default:
       error("Invalid primitive type");
       break;
@@ -445,6 +446,8 @@ std::string CppWriter::getCppName(const Value* val) {
     } else {
       name = getTypePrefix(val->getType());
     }
+  } else if (dyn_cast<MDNode>(val)) {
+	  name = std::string("metadata_");
   } else {
     name = getTypePrefix(val->getType());
   }
@@ -1411,6 +1414,10 @@ void CppWriter::printInstruction(const Instruction *I,
           << (ila->hasSideEffects() ? "true" : "false") << ");";
       nl(Out);
     }
+    if (const Function* F = dyn_cast<Function>(call->getCalledValue())) {
+    	if ((F->getName().compare("llvm.dbg.value") == 0) || (F->getName().compare("llvm.dbg.declare") == 0))
+    		break;	//Generate nothing
+    }
     if (call->getNumArgOperands() > 1) {
       Out << "std::vector<Value*> " << iName << "_params;";
       nl(Out);
