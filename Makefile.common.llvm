#
# Configuration file to set paths specific to local installation of LLVM
#

# Define LLVM specific info and directories based on the autoconf variables
LLVMPackageName   := llvm
LLVMVersion       := 3.3svn
LLVM_CONFIGTIME   := Sat Dec  8 22:34:42 CET 2012

###########################################################################
# Directory Configuration
#	This section of the Makefile determines what is where.  To be
#	specific, there are several locations that need to be defined:
#
#	o LLVM_SRC_ROOT  : The root directory of the LLVM source code.
#	o LLVM_OBJ_ROOT  : The root directory containing the built LLVM code.
#
#	o PROJ_SRC_DIR  : The directory containing the code to build.
#	o PROJ_SRC_ROOT : The root directory of the code to build.
#
#	o PROJ_OBJ_DIR  : The directory in which compiled code will be placed.
#	o PROJ_OBJ_ROOT : The root directory in which compiled code is placed.
#
###########################################################################

PWD := /bin/pwd
# Set the project name to LLVM if its not defined
ifndef PROJECT_NAME
PROJECT_NAME := $(LLVMPackageName)
endif

# The macro below is expanded when 'realpath' is not built-in.
# Built-in 'realpath' is available on GNU Make 3.81.
realpath = $(shell cd $(1); $(PWD))

PROJ_OBJ_DIR  := $(call realpath, .)
PROJ_OBJ_ROOT := $(call realpath, $(PROJ_OBJ_DIR)/$(LEVEL))

CLANG_SRC_ROOT  := 

ifeq ($(PROJECT_NAME),$(LLVMPackageName))
LLVM_SRC_ROOT   := $(call realpath, /home/gael/vmkit/llvm)
LLVM_OBJ_ROOT   := $(call realpath, /home/gael/vmkit/llvm)
PROJ_SRC_ROOT   := $(LLVM_SRC_ROOT)
PROJ_SRC_DIR    := $(LLVM_SRC_ROOT)$(patsubst $(PROJ_OBJ_ROOT)%,%,$(PROJ_OBJ_DIR))

ifneq ($(CLANG_SRC_ROOT),)
  CLANG_SRC_ROOT:= $(call realpath, $(CLANG_SRC_ROOT))
  PROJ_SRC_DIR  := $(patsubst $(LLVM_SRC_ROOT)/tools/clang%,$(CLANG_SRC_ROOT)%,$(PROJ_SRC_DIR))
endif

prefix          := /usr/local
PROJ_prefix     := $(prefix)
program_prefix  := 
PROJ_VERSION    := $(LLVMVersion)
else
ifndef PROJ_SRC_ROOT
$(error Projects must define PROJ_SRC_ROOT)
endif
ifndef PROJ_OBJ_ROOT
$(error Projects must define PROJ_OBJ_ROOT)
endif
ifndef PROJ_INSTALL_ROOT
$(error Projects must define PROJ_INSTALL_ROOT)
endif
ifndef LLVM_SRC_ROOT
$(error Projects must define LLVM_SRC_ROOT)
endif
ifndef LLVM_OBJ_ROOT
$(error Projects must define LLVM_OBJ_ROOT)
endif
PROJ_SRC_DIR := $(call realpath, $(PROJ_SRC_ROOT)/$(patsubst $(PROJ_OBJ_ROOT)%,%,$(PROJ_OBJ_DIR)))
prefix          := $(PROJ_INSTALL_ROOT)
PROJ_prefix     := $(prefix)
ifndef PROJ_VERSION
PROJ_VERSION := 1.0
endif
endif

INTERNAL_PREFIX := 
ifneq ($(INTERNAL_PREFIX),)
PROJ_internal_prefix := $(INTERNAL_PREFIX)
else
PROJ_internal_prefix := $(prefix)
endif

PROJ_bindir     := $(PROJ_prefix)/bin
PROJ_libdir     := $(PROJ_prefix)/lib
PROJ_datadir    := $(PROJ_prefix)/share
PROJ_docsdir    := $(PROJ_prefix)/docs/llvm
PROJ_etcdir     := $(PROJ_prefix)/etc/llvm
PROJ_includedir := $(PROJ_prefix)/include
PROJ_infodir    := $(PROJ_prefix)/info
PROJ_mandir     := $(PROJ_prefix)/share/man

# Determine if we're on a unix type operating system
LLVM_ON_UNIX:=1
LLVM_ON_WIN32:=0

# Host operating system for which LLVM will be run.
OS=Linux
HOST_OS=Linux
# Target operating system for which LLVM will compile for.
TARGET_OS=Linux

# Host hardware architecture
HOST_ARCH=x86_64
# Target hardware architecture
ARCH=x86_64
TARGET_NATIVE_ARCH := $(ARCH)

# Indicates, whether we're cross-compiling LLVM or not
LLVM_CROSS_COMPILING=0

# Executable file extension for build platform (mainly for
# tablegen call if we're cross-compiling).
BUILD_EXEEXT=

# Compilers for the build platflorm (mainly for tablegen
# call if we're cross-compiling).
BUILD_CC=
BUILD_CXX=

# Triple for configuring build tools when cross-compiling
BUILD_TRIPLE=x86_64-unknown-linux-gnu

# Target triple (cpu-vendor-os) for which we should generate code
TARGET_TRIPLE=x86_64-unknown-linux-gnu

# Extra options to compile LLVM with
EXTRA_OPTIONS=

# Extra options to link LLVM with
EXTRA_LD_OPTIONS=

# Endian-ness of the target
ENDIAN=little

# Path to the C++ compiler to use.  This is an optional setting, which defaults
# to whatever your gmake defaults to.
CXX = g++

# Path to the CC binary, which use used by testcases for native builds.
CC := gcc

# Linker flags.
LDFLAGS+=

# Path to the library archiver program.
AR_PATH = ar
AR = ar

# Path to the nm program
NM_PATH = /usr/bin/nm -B

# The pathnames of the programs we require to build
CMP        := /usr/bin/cmp
CP         := /bin/cp
DATE       := /bin/date
FIND       := /usr/bin/find
GREP       := /bin/grep
INSTALL    := /usr/bin/install -c
MKDIR      := $(LLVM_SRC_ROOT)/autoconf/mkinstalldirs
MV         := /bin/mv
RANLIB     := ranlib
RM         := /bin/rm
SED        := /bin/sed
TAR        := /bin/tar

# Paths to miscellaneous programs we hope are present but might not be
BZIP2      := /bin/bzip2
CAT        := /bin/cat
DOT        := echo dot
DOXYGEN    := 
GROFF      := /usr/bin/groff
GZIPBIN    := /bin/gzip
OCAMLC     := 
OCAMLOPT   := 
OCAMLDEP   := 
OCAMLDOC   := 
GAS        := /usr/bin/as
POD2HTML   := @POD2HTML@
POD2MAN    := @POD2MAN@
PDFROFF    := 
ZIP        := 

HAVE_PTHREAD := 1

LIBS       := -lpthread -ldl -lm 

# Targets that we should build
TARGETS_TO_BUILD=X86 Sparc PowerPC ARM Mips XCore MSP430 CppBackend MBlaze NVPTX Hexagon

# Path to directory where object files should be stored during a build.
# Set OBJ_ROOT to "." if you do not want to use a separate place for
# object files.
OBJ_ROOT := .

# What to pass as rpath flag to g++
RPATH := -Wl,-R

# What to pass as -rdynamic flag to g++
RDYNAMIC := -Wl,-export-dynamic

# These are options that can either be enabled here, or can be enabled on the
# make command line (ie, make ENABLE_PROFILING=1):

# When ENABLE_LIBCPP is enabled, LLVM uses libc++ by default to build.
#ENABLE_LIBCPP = 0
ENABLE_LIBCPP = 0

# When ENABLE_CXX11 is enabled, LLVM uses c++11 mode by default to build.
ENABLE_CXX11 = 0

# When ENABLE_WERROR is enabled, we'll pass -Werror on the command line
ENABLE_WERROR = 0

# When ENABLE_OPTIMIZED is enabled, LLVM code is optimized and output is put
# into the "Release" directories. Otherwise, LLVM code is not optimized and
# output is put in the "Debug" directories.
#ENABLE_OPTIMIZED = 1
ENABLE_OPTIMIZED=1

# When ENABLE_PROFILING is enabled, profile instrumentation is done
# and output is put into the "<Flavor>+Profile" directories, where
# <Flavor> is either Debug or Release depending on how other build
# flags are set. Otherwise, output is put in the <Flavor>
# directories.
#ENABLE_PROFILING = 1


# When DISABLE_ASSERTIONS is enabled, builds of all of the LLVM code will
# exclude assertion checks, otherwise they are included.
#DISABLE_ASSERTIONS = 1


# When ENABLE_EXPENSIVE_CHECKS is enabled, builds of all of the LLVM
# code will include expensive checks, otherwise they are excluded.
#ENABLE_EXPENSIVE_CHECKS = 0


# When DEBUG_RUNTIME is enabled, the runtime libraries will retain debug
# symbols.
#DEBUG_RUNTIME = 1


# When DEBUG_SYMBOLS is enabled, the compiler libraries will retain debug
# symbols.
#DEBUG_SYMBOLS = 1


# When KEEP_SYMBOLS is enabled, installed executables will never have their
# symbols stripped.
#KEEP_SYMBOLS = 1


# The compiler flags to use for optimized builds.
OPTIMIZE_OPTION := -O3

# When ENABLE_PROFILING is enabled, the llvm source base is built with profile
# information to allow gprof to be used to get execution frequencies.
#ENABLE_PROFILING = 1

# When ENABLE_DOCS is disabled, docs/ will not be built.
ENABLE_DOCS = 1

# When ENABLE_DOXYGEN is enabled, the doxygen documentation will be built
ENABLE_DOXYGEN = 0

# Do we want to enable threads?
ENABLE_THREADS := @ENABLE_THREADS@

# Do we want to build with position independent code?
ENABLE_PIC := 1

# Do we want to build a shared library and link the tools with it?
ENABLE_SHARED := 0

# Do we want to link the stdc++ into a shared library? (Cygming)
ENABLE_EMBED_STDCXX := 0

# Use -fvisibility-inlines-hidden?
ENABLE_VISIBILITY_INLINES_HIDDEN := 1

# Do we want to allow timestamping information into builds?
ENABLE_TIMESTAMPS := 1

# This option tells the Makefiles to produce verbose output.
# It essentially prints the commands that make is executing
#VERBOSE = 1

# Enable JIT for this platform
TARGET_HAS_JIT = 1

# Environment variable to set to change the runtime shared library search path.
SHLIBPATH_VAR = LD_LIBRARY_PATH

# Shared library extension for host platform.
SHLIBEXT = .so

# Executable file extension for host platform.
EXEEXT = 

# Things we just assume are "there"
ECHO := echo

# Get the options for causing archives to link all their content instead of
# just missing symbols, and the inverse of that. This is used for certain LLVM
# tools that permit loadable modules. It ensures that the LLVM symbols will be
# available to those loadable modules.
LINKALL := -Wl,--whole-archive
NOLINKALL := -Wl,--no-whole-archive

# Get the value of HUGE_VAL_SANITY which will be either "yes" or "no" depending
# on the check.
HUGE_VAL_SANITY = yes

# Bindings that we should build
BINDINGS_TO_BUILD := 
ALL_BINDINGS      := ocaml
OCAML_LIBDIR      := 

# When compiling under Mingw/Cygwin, executables such as tblgen
# expect Windows paths, whereas the build system uses Unix paths.
# The function SYSPATH transforms Unix paths into Windows paths.
ifneq (,$(findstring -mno-cygwin, $(CXX)))
  SYSPATH = $(shell echo $(1) | cygpath -m -f -)
else
  SYSPATH = $(1)
endif

# Location of the plugin header file for gold.
BINUTILS_INCDIR := 

# Optional flags supported by the compiler
# -Wno-missing-field-initializers
NO_MISSING_FIELD_INITIALIZERS = -Wno-missing-field-initializers
# -Wno-variadic-macros
NO_VARIADIC_MACROS = -Wno-variadic-macros
# -Wcovered-switch-default
COVERED_SWITCH_DEFAULT = 

# Was polly found in tools/polly?
LLVM_HAS_POLLY = 
# Flags supported by the linker.
# bfd ld / gold --version-script=file
HAVE_LINK_VERSION_SCRIPT = 1

# Flags to control using libxml2
LIBXML2_LIBS := 
LIBXML2_INC  := 

# Flags to control building support for Intel JIT Events API
USE_INTEL_JITEVENTS := 0
INTEL_JITEVENTS_INCDIR := @INTEL_JITEVENTS_INCDIR@
INTEL_JITEVENTS_LIBDIR := @INTEL_JITEVENTS_LIBDIR@

# Flags to control building support for OProfile JIT API
USE_OPROFILE := 0

ifeq ($(USE_INTEL_JITEVENTS), 1)
  OPTIONAL_COMPONENTS += IntelJITEvents
endif
ifeq ($(USE_OPROFILE), 1)
  OPTIONAL_COMPONENTS += OProfileJIT
endif

#===-- Makefile.rules - Common make rules for LLVM ---------*- Makefile -*--===#
#
#                     The LLVM Compiler Infrastructure
#
# This file is distributed under the University of Illinois Open Source
# License. See LICENSE.TXT for details.
#
#===------------------------------------------------------------------------===#
#
# This file is included by all of the LLVM makefiles.  For details on how to use
# it properly, please see the document MakefileGuide.html in the docs directory.
#
#===-----------------------------------------------------------------------====#

################################################################################
# TARGETS: Define standard targets that can be invoked
################################################################################

#--------------------------------------------------------------------
# Define the various target sets
#--------------------------------------------------------------------
RecursiveTargets := all clean clean-all install uninstall install-bytecode \
                    unitcheck
LocalTargets     := all-local clean-local clean-all-local check-local \
                    install-local printvars uninstall-local \
		    install-bytecode-local
TopLevelTargets  := check dist dist-check dist-clean dist-gzip dist-bzip2 \
                    dist-zip unittests
UserTargets      := $(RecursiveTargets) $(LocalTargets) $(TopLevelTargets)
InternalTargets  := preconditions distdir dist-hook

################################################################################
# INITIALIZATION: Basic things the makefile needs
################################################################################

#--------------------------------------------------------------------
# Set the VPATH so that we can find source files.
#--------------------------------------------------------------------
VPATH=$(PROJ_SRC_DIR)

#--------------------------------------------------------------------
# Reset the list of suffixes we know how to build.
#--------------------------------------------------------------------
.SUFFIXES:
.SUFFIXES: .c .cpp .cc .h .hpp .o .a .bc .td .ps .dot .ll .m .mm
.SUFFIXES: $(SHLIBEXT) $(SUFFIXES)

#--------------------------------------------------------------------
# Mark all of these targets as phony to avoid implicit rule search
#--------------------------------------------------------------------
.PHONY: $(UserTargets) $(InternalTargets)

#--------------------------------------------------------------------
# Make sure all the user-target rules are double colon rules and
# they are defined first.
#--------------------------------------------------------------------

$(UserTargets)::

#------------------------------------------------------------------------
# LLVMBuild Integration
#------------------------------------------------------------------------
#
# We use llvm-build to generate all the data required by the Makefile based
# build system in one swoop:
#
#  - We generate a file (a Makefile fragment) in the object root which contains
#    all the definitions that are required by Makefiles across the entire
#    project.
#
#  - We generate the library table used by llvm-config.
#
#  - We generate the dependencies for the Makefile fragment, so that we will
#    automatically reconfigure outselves.

# The path to the llvm-build tool itself.
LLVMBuildTool	:= $(PROJ_SRC_ROOT)/utils/llvm-build/llvm-build

# The files we are going to generate using llvm-build.
LLVMBuildMakeFrag := $(PROJ_OBJ_ROOT)/Makefile.llvmbuild
LLVMConfigLibraryDependenciesInc := \
	$(PROJ_OBJ_ROOT)/tools/llvm-config/LibraryDependencies.inc

# This is for temporary backwards compatibility.
ifndef TARGET_NATIVE_ARCH
TARGET_NATIVE_ARCH := $(ARCH)
endif

# The rule to create the LLVMBuild Makefile fragment as well as the llvm-config
# library table.
#
# Note that this target gets its real dependencies generated for us by
# llvm-build.
#
# We include a dependency on this Makefile to ensure that changes to the
# generation command get picked up.
$(LLVMBuildMakeFrag): $(PROJ_SRC_ROOT)/Makefile.rules \
		      $(PROJ_OBJ_ROOT)/Makefile.config
	$(Echo) Constructing LLVMBuild project information.
	$(Verb) $(LLVMBuildTool) \
	  --native-target "$(TARGET_NATIVE_ARCH)" \
	  --enable-targets "$(TARGETS_TO_BUILD)" \
	  --enable-optional-components "$(OPTIONAL_COMPONENTS)" \
	  --write-library-table $(LLVMConfigLibraryDependenciesInc) \
	  --write-make-fragment $(LLVMBuildMakeFrag)

# For completeness, let Make know how the extra files are generated.
$(LLVMConfigLibraryDependenciesInc): $(LLVMBuildMakeFrag)

# Include the generated Makefile fragment.
#
# We currently only include the dependencies for the fragment itself if we are
# at the top-level. Otherwise, recursive invocations would ends up doing
# substantially more redundant stat'ing.
#
# This means that we won't properly regenerate things for developers used to
# building from a subdirectory, but that is always somewhat unreliable.
ifeq ($(LEVEL),.)
LLVMBUILD_INCLUDE_DEPENDENCIES := 1

# Clean the generated makefile fragment at the top-level.
clean-local::
	-$(Verb) $(RM) -f $(LLVMBuildMakeFrag)
endif
-include $(LLVMBuildMakeFrag)

################################################################################
# PRECONDITIONS: that which must be built/checked first
################################################################################

SrcMakefiles       := $(filter %Makefile %Makefile.tests,\
                      $(wildcard $(PROJ_SRC_DIR)/Makefile*))
ObjMakefiles       := $(subst $(PROJ_SRC_DIR),$(PROJ_OBJ_DIR),$(SrcMakefiles))
ConfigureScript    := $(PROJ_SRC_ROOT)/configure
ConfigStatusScript := $(PROJ_OBJ_ROOT)/config.status
MakefileConfigIn   := $(strip $(wildcard $(PROJ_SRC_ROOT)/Makefile.config.in))
MakefileCommonIn   := $(strip $(wildcard $(PROJ_SRC_ROOT)/Makefile.common.in))
MakefileConfig     := $(PROJ_OBJ_ROOT)/Makefile.config
MakefileCommon     := $(PROJ_OBJ_ROOT)/Makefile.common
PreConditions      := $(ConfigStatusScript) $(ObjMakefiles)
ifneq ($(MakefileCommonIn),)
PreConditions      += $(MakefileCommon)
endif

ifneq ($(MakefileConfigIn),)
PreConditions      += $(MakefileConfig)
endif

preconditions: $(PreConditions)

#------------------------------------------------------------------------
# Make sure the BUILT_SOURCES are built first
#------------------------------------------------------------------------
$(filter-out clean clean-local,$(UserTargets)):: $(BUILT_SOURCES)

clean-all-local::
ifneq ($(strip $(BUILT_SOURCES)),)
	-$(Verb) $(RM) -f $(BUILT_SOURCES)
endif

ifneq ($(PROJ_OBJ_ROOT),$(PROJ_SRC_ROOT))
spotless:
	$(Verb) if test -x config.status ; then \
	  $(EchoCmd) Wiping out $(PROJ_OBJ_ROOT) ; \
	  $(MKDIR) .spotless.save ; \
	  $(MV) config.status .spotless.save ; \
	  $(MV) mklib  .spotless.save ; \
	  $(MV) projects  .spotless.save ; \
	  $(RM) -rf * ; \
	  $(MV) .spotless.save/config.status . ; \
	  $(MV) .spotless.save/mklib . ; \
	  $(MV) .spotless.save/projects . ; \
	  $(RM) -rf .spotless.save ; \
	  $(EchoCmd) Rebuilding configuration of $(PROJ_OBJ_ROOT) ; \
	  $(ConfigStatusScript) --recheck $(ConfigureScriptFLAGS) && \
	  $(ConfigStatusScript) ; \
	else \
	  $(EchoCmd) "make spotless" can only be run from $(PROJ_OBJ_ROOT); \
	fi
else
spotless:
	$(EchoCmd) "spotless target not supported for objdir == srcdir"
endif

$(BUILT_SOURCES) : $(ObjMakefiles)

#------------------------------------------------------------------------
# Make sure we're not using a stale configuration
#------------------------------------------------------------------------
reconfigure:
	$(Echo) Reconfiguring $(PROJ_OBJ_ROOT)
	$(Verb) cd $(PROJ_OBJ_ROOT) && \
	  $(ConfigStatusScript) --recheck $(ConfigureScriptFLAGS) && \
	  $(ConfigStatusScript)

.PRECIOUS: $(ConfigStatusScript)
$(ConfigStatusScript): $(ConfigureScript)
	$(Echo) Reconfiguring with $<
	$(Verb) cd $(PROJ_OBJ_ROOT) && \
	  $(ConfigStatusScript) --recheck $(ConfigureScriptFLAGS) && \
	  $(ConfigStatusScript)

#------------------------------------------------------------------------
# Make sure the configuration makefile is up to date
#------------------------------------------------------------------------
ifneq ($(MakefileConfigIn),)
$(MakefileConfig): $(MakefileConfigIn) $(ConfigStatusScript)
	$(Echo) Regenerating $@
	$(Verb) cd $(PROJ_OBJ_ROOT) ; $(ConfigStatusScript) Makefile.config
endif

ifneq ($(MakefileCommonIn),)
$(MakefileCommon): $(MakefileCommonIn) $(ConfigStatusScript)
	$(Echo) Regenerating $@
	$(Verb) cd $(PROJ_OBJ_ROOT) ; $(ConfigStatusScript) Makefile.common
endif

#------------------------------------------------------------------------
# If the Makefile in the source tree has been updated, copy it over into the
# build tree. But, only do this if the source and object makefiles differ
#------------------------------------------------------------------------
ifndef PROJ_MAKEFILE
PROJ_MAKEFILE := $(PROJ_SRC_DIR)/Makefile
endif

ifneq ($(PROJ_OBJ_DIR),$(PROJ_SRC_DIR))

Makefile: $(PROJ_MAKEFILE) $(ExtraMakefiles)
	$(Echo) "Updating Makefile"
	$(Verb) $(MKDIR) $(@D)
	$(Verb) $(CP) -f $< $@

# Copy the Makefile.* files unless we're in the root directory which avoids
# the copying of Makefile.config.in or other things that should be explicitly
# taken care of.
$(PROJ_OBJ_DIR)/Makefile% : $(PROJ_MAKEFILE)%
	@case '$?' in \
          *Makefile.rules) ;; \
          *.in) ;; \
          *) $(EchoCmd) "Updating $(@F)" ; \
	     $(MKDIR) $(@D) ; \
	     $(CP) -f $< $@ ;; \
	esac

endif

#------------------------------------------------------------------------
# Set up the basic dependencies
#------------------------------------------------------------------------
$(UserTargets):: $(PreConditions)

all:: all-local
clean:: clean-local
clean-all:: clean-local clean-all-local
install:: install-local
uninstall:: uninstall-local
install-local:: all-local
install-bytecode:: install-bytecode-local

###############################################################################
# VARIABLES: Set up various variables based on configuration data
###############################################################################

# Variable for if this make is for a "cleaning" target
ifneq ($(strip $(filter clean clean-local dist-clean,$(MAKECMDGOALS))),)
  IS_CLEANING_TARGET=1
endif

#--------------------------------------------------------------------
# Variables derived from configuration we are building
#--------------------------------------------------------------------

CPP.Defines :=
ifeq ($(ENABLE_OPTIMIZED),1)
  BuildMode := Release
  # Don't use -fomit-frame-pointer on Darwin or FreeBSD.
  ifneq ($(HOST_OS),FreeBSD)
  ifneq ($(HOST_OS),Darwin)
    OmitFramePointer := -fomit-frame-pointer
  endif
  endif

  # Darwin requires -fstrict-aliasing to be explicitly enabled.
  # Avoid -fstrict-aliasing on Darwin for now, there are unresolved issues
  # with -fstrict-aliasing and ipa-type-escape radr://6756684
  #ifeq ($(HOST_OS),Darwin)
  #  EXTRA_OPTIONS += -fstrict-aliasing -Wstrict-aliasing
  #endif
  CXX.Flags += $(OPTIMIZE_OPTION) $(OmitFramePointer)
  C.Flags   += $(OPTIMIZE_OPTION) $(OmitFramePointer)
  LD.Flags  += $(OPTIMIZE_OPTION)
  ifdef DEBUG_SYMBOLS
    BuildMode := $(BuildMode)+Debug
    CXX.Flags += -g
    C.Flags   += -g
    LD.Flags  += -g
    KEEP_SYMBOLS := 1
  endif
else
  ifdef NO_DEBUG_SYMBOLS
    BuildMode := Unoptimized
    CXX.Flags +=
    C.Flags   +=
    LD.Flags  +=
    KEEP_SYMBOLS := 1
  else
    BuildMode := Debug
    CXX.Flags += -g
    C.Flags   += -g
    LD.Flags  += -g
    KEEP_SYMBOLS := 1
  endif
endif

ifeq ($(ENABLE_LIBCPP),1)
  CXX.Flags +=  -stdlib=libc++
  LD.Flags +=  -stdlib=libc++
endif

ifeq ($(ENABLE_CXX11),1)
  CXX.Flags += -std=c++11
endif

ifeq ($(ENABLE_WERROR),1)
  CXX.Flags += -Werror
  C.Flags += -Werror
endif

ifeq ($(ENABLE_PROFILING),1)
  BuildMode := $(BuildMode)+Profile
  CXX.Flags := $(filter-out -fomit-frame-pointer,$(CXX.Flags)) -pg -g
  C.Flags   := $(filter-out -fomit-frame-pointer,$(C.Flags)) -pg -g
  LD.Flags  := $(filter-out -fomit-frame-pointer,$(LD.Flags)) -pg -g
  KEEP_SYMBOLS := 1
endif

ifeq ($(ENABLE_VISIBILITY_INLINES_HIDDEN),1)
    CXX.Flags += -fvisibility-inlines-hidden
endif

ifdef ENABLE_EXPENSIVE_CHECKS
  # GNU libstdc++ uses RTTI if you define _GLIBCXX_DEBUG, which we did above.
  # See http://gcc.gnu.org/bugzilla/show_bug.cgi?id=40160
  REQUIRES_RTTI := 1
endif

# IF REQUIRES_EH=1 is specified then don't disable exceptions
ifndef REQUIRES_EH
  CXX.Flags += -fno-exceptions
else
  # If the library requires EH, it also requires RTTI.
  REQUIRES_RTTI := 1
endif

ifdef REQUIRES_FRAME_POINTER
  CXX.Flags := $(filter-out -fomit-frame-pointer,$(CXX.Flags))
  C.Flags   := $(filter-out -fomit-frame-pointer,$(C.Flags))
  LD.Flags  := $(filter-out -fomit-frame-pointer,$(LD.Flags))
endif

# If REQUIRES_RTTI=1 is specified then don't disable run-time type id.
ifneq ($(REQUIRES_RTTI), 1)
  CXX.Flags += -fno-rtti
endif

ifeq ($(ENABLE_COVERAGE),1)
  BuildMode := $(BuildMode)+Coverage
  CXX.Flags += -ftest-coverage -fprofile-arcs
  C.Flags   += -ftest-coverage -fprofile-arcs
endif

# If DISABLE_ASSERTIONS=1 is specified (make command line or configured),
# then disable assertions by defining the appropriate preprocessor symbols.
ifeq ($(DISABLE_ASSERTIONS),1)
  CPP.Defines += -DNDEBUG
else
  BuildMode := $(BuildMode)+Asserts
  CPP.Defines += -D_DEBUG
endif

# If ENABLE_EXPENSIVE_CHECKS=1 is specified (make command line or
# configured), then enable expensive checks by defining the
# appropriate preprocessor symbols.
ifeq ($(ENABLE_EXPENSIVE_CHECKS),1)
  BuildMode := $(BuildMode)+Checks
  CPP.Defines += -D_GLIBCXX_DEBUG -DXDEBUG
endif

# LOADABLE_MODULE implies several other things so we force them to be
# defined/on.
ifdef LOADABLE_MODULE
  SHARED_LIBRARY := 1
  LINK_LIBS_IN_SHARED := 1
endif

ifdef SHARED_LIBRARY
  ENABLE_PIC := 1
  PIC_FLAG = "(PIC)"
endif

ifeq ($(ENABLE_PIC),1)
  ifeq ($(HOST_OS), $(filter $(HOST_OS), Cygwin MingW))
    # Nothing. Win32 defaults to PIC and warns when given -fPIC
  else
    ifeq ($(HOST_OS),Darwin)
      # Common symbols not allowed in dylib files
      CXX.Flags += -fno-common
      C.Flags   += -fno-common
    else
      # Linux and others; pass -fPIC
      CXX.Flags += -fPIC
      C.Flags   += -fPIC
    endif
  endif
else
  ifeq ($(HOST_OS),Darwin)
      CXX.Flags += -mdynamic-no-pic
      C.Flags   += -mdynamic-no-pic
  endif
endif

# Support makefile variable to disable any kind of timestamp/non-deterministic
# info from being used in the build.
ifeq ($(ENABLE_TIMESTAMPS),1)
  DOTDIR_TIMESTAMP_COMMAND := $(DATE)
else
  DOTDIR_TIMESTAMP_COMMAND := echo 'Created.'
endif

ifeq ($(HOST_OS),MingW)
  # Work around PR4957
  CPP.Defines += -D__NO_CTYPE_INLINE
  ifeq ($(LLVM_CROSS_COMPILING),1)
    # Work around http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=525016
    ifdef TOOLNAME
      LD.Flags += -Wl,--allow-multiple-definition
    endif
  endif
endif

CXX.Flags     += -Woverloaded-virtual
CPP.BaseFlags += $(CPP.Defines)
AR.Flags      := cru

# Make Floating point IEEE compliant on Alpha.
ifeq ($(ARCH),Alpha)
  CXX.Flags     += -mieee
  CPP.BaseFlags += -mieee
ifeq ($(ENABLE_PIC),0)
  CXX.Flags     += -fPIC
  CPP.BaseFlags += -fPIC
endif

  LD.Flags += -Wl,--no-relax
endif

# GNU ld/PECOFF accepts but ignores them below;
#   --version-script
#   --export-dynamic
#   --rpath
# FIXME: autoconf should be aware of them.
ifneq (,$(filter $(HOST_OS),Cygwin MingW))
  HAVE_LINK_VERSION_SCRIPT := 0
  RPATH :=
  RDYNAMIC := -Wl,--export-all-symbols
endif

#--------------------------------------------------------------------
# Directory locations
#--------------------------------------------------------------------
TargetMode :=
ifeq ($(LLVM_CROSS_COMPILING),1)
  BuildLLVMToolDir := $(LLVM_OBJ_ROOT)/BuildTools/$(BuildMode)/bin
endif

ObjRootDir  := $(PROJ_OBJ_DIR)/$(BuildMode)
ObjDir      := $(ObjRootDir)
LibDir      := $(PROJ_OBJ_ROOT)/$(BuildMode)/lib
ToolDir     := $(PROJ_OBJ_ROOT)/$(BuildMode)/bin
ExmplDir    := $(PROJ_OBJ_ROOT)/$(BuildMode)/examples
LLVMLibDir  := $(LLVM_OBJ_ROOT)/$(BuildMode)/lib
LLVMToolDir := $(LLVM_OBJ_ROOT)/$(BuildMode)/bin
LLVMExmplDir:= $(LLVM_OBJ_ROOT)/$(BuildMode)/examples

#--------------------------------------------------------------------
# Locations of shared libraries
#--------------------------------------------------------------------

SharedPrefix     := lib
SharedLibDir     := $(LibDir)
LLVMSharedLibDir := $(LLVMLibDir)

# Win32.DLL prefers to be located on the "PATH" of binaries.
ifeq ($(HOST_OS), $(filter $(HOST_OS), Cygwin MingW))
  SharedLibDir     := $(ToolDir)
  LLVMSharedLibDir := $(LLVMToolDir)

  ifeq ($(HOST_OS),Cygwin)
    SharedPrefix  := cyg
  else
    SharedPrefix  :=
  endif
endif

#--------------------------------------------------------------------
# LLVM Capable Compiler
#--------------------------------------------------------------------

ifneq ($(findstring llvm-gcc,$(LLVMCC_OPTION)),)
  LLVMCC := $(LLVMGCC)
  LLVMCXX := $(LLVMGXX)
else
  ifneq ($(findstring clang,$(LLVMCC_OPTION)),)
    ifneq ($(CLANGPATH),)
      LLVMCC := $(CLANGPATH)
      LLVMCXX := $(CLANGXXPATH)
    else
      ifeq ($(ENABLE_BUILT_CLANG),1)
        LLVMCC := $(LLVMToolDir)/clang
        LLVMCXX := $(LLVMToolDir)/clang++
      endif
    endif
  endif
endif

#--------------------------------------------------------------------
# Full Paths To Compiled Tools and Utilities
#--------------------------------------------------------------------
EchoCmd  := $(ECHO) llvm[$(MAKELEVEL)]:
ifdef BUILD_DIRS_ONLY
EchoCmd  := $(EchoCmd) "(build tools)":
endif

Echo     := @$(EchoCmd)
ifndef LLVMAS
LLVMAS   := $(LLVMToolDir)/llvm-as$(EXEEXT)
endif
ifndef LLVM_TBLGEN
  ifeq ($(LLVM_CROSS_COMPILING),1)
    LLVM_TBLGEN   := $(BuildLLVMToolDir)/llvm-tblgen$(BUILD_EXEEXT)
  else
    LLVM_TBLGEN   := $(LLVMToolDir)/llvm-tblgen$(EXEEXT)
  endif
endif
ifeq ($(LLVM_CROSS_COMPILING),1)
  LLVM_CONFIG := $(BuildLLVMToolDir)/llvm-config$(BUILD_EXEEXT)
else
  LLVM_CONFIG := $(LLVMToolDir)/llvm-config$(EXEEXT)
endif
ifndef LLVMDIS
LLVMDIS  := $(LLVMToolDir)/llvm-dis$(EXEEXT)
endif
ifndef LLI
LLI      := $(LLVMToolDir)/lli$(EXEEXT)
endif
ifndef LLC
LLC      := $(LLVMToolDir)/llc$(EXEEXT)
endif
ifndef LOPT
LOPT     := $(LLVMToolDir)/opt$(EXEEXT)
endif
ifndef LBUGPOINT
LBUGPOINT := $(LLVMToolDir)/bugpoint$(EXEEXT)
endif
ifndef LLVMLINK
LLVMLINK      := $(LLVMToolDir)/llvm-link$(EXEEXT)
endif

#--------------------------------------------------------------------
# Adjust to user's request
#--------------------------------------------------------------------

ifeq ($(HOST_OS),Darwin)
 ifdef MACOSX_DEPLOYMENT_TARGET
  DARWIN_VERSION := $(MACOSX_DEPLOYMENT_TARGET)
 else
  DARWIN_VERSION := `sw_vers -productVersion`
 endif
  # Strip a number like 10.4.7 to 10.4
  DARWIN_VERSION := $(shell echo $(DARWIN_VERSION)| sed -E 's/(10.[0-9]).*/\1/')
  # Get "4" out of 10.4 for later pieces in the makefile.
  DARWIN_MAJVERS := $(shell echo $(DARWIN_VERSION)| sed -E 's/10.([0-9]).*/\1/')

  LoadableModuleOptions := -Wl,-flat_namespace -Wl,-undefined,suppress
  SharedLinkOptions := -dynamiclib
  ifneq ($(ARCH),ARM)
    SharedLinkOptions += -mmacosx-version-min=$(DARWIN_VERSION)
  endif
else
  SharedLinkOptions=-shared
endif

ifeq ($(TARGET_OS),Darwin)
  ifneq ($(ARCH),ARM)
    TargetCommonOpts += -mmacosx-version-min=$(DARWIN_VERSION)
  endif
endif

ifdef SHARED_LIBRARY
ifneq ($(HOST_OS), $(filter $(HOST_OS), Cygwin MingW))
ifneq ($(HOST_OS),Darwin)
  LD.Flags += $(RPATH) -Wl,'$$ORIGIN'
endif
endif
endif

ifdef TOOL_VERBOSE
  C.Flags += -v
  CXX.Flags += -v
  LD.Flags += -v
  VERBOSE := 1
endif

# Adjust settings for verbose mode
ifndef VERBOSE
  Verb := @
  AR.Flags += >/dev/null 2>/dev/null
  ConfigureScriptFLAGS += >$(PROJ_OBJ_DIR)/configure.out 2>&1
else
  ConfigureScriptFLAGS :=
endif

# By default, strip symbol information from executable
ifndef KEEP_SYMBOLS
  Strip := $(PLATFORMSTRIPOPTS)
  StripWarnMsg := "(without symbols)"
  Install.StripFlag += -s
endif

ifdef TOOL_NO_EXPORTS
  DynamicFlags :=
else
  DynamicFlag := $(RDYNAMIC)
endif

# Adjust linker flags for building an executable
ifneq ($(HOST_OS), $(filter $(HOST_OS), Cygwin MingW))
  ifneq ($(HOST_OS), Darwin)
    ifdef TOOLNAME
      LD.Flags += $(RPATH) -Wl,'$$ORIGIN/../lib'
      ifdef EXAMPLE_TOOL
        LD.Flags += $(RPATH) -Wl,$(ExmplDir) $(DynamicFlag)
      else
        LD.Flags += $(RPATH) -Wl,$(ToolDir) $(DynamicFlag)
    endif
  endif
else
  ifneq ($(DARWIN_MAJVERS),4)
    LD.Flags += $(RPATH) -Wl,@executable_path/../lib
  endif
  ifeq ($(RC_BUILDIT),YES)
    TempFile := $(shell mkdir -p ${OBJROOT}/dSYMs ; mktemp ${OBJROOT}/dSYMs/llvm-lto.XXXXXX)
    LD.Flags += -Wl,-object_path_lto -Wl,$(TempFile)
  endif
endif
endif


#----------------------------------------------------------
# Options To Invoke Tools
#----------------------------------------------------------

ifdef EXTRA_LD_OPTIONS
LD.Flags += $(EXTRA_LD_OPTIONS)
endif

ifndef NO_PEDANTIC
CompileCommonOpts += -pedantic -Wno-long-long
endif
CompileCommonOpts += -Wall -W -Wno-unused-parameter -Wwrite-strings \
                     $(EXTRA_OPTIONS) $(COVERED_SWITCH_DEFAULT)
# Enable cast-qual for C++; the workaround is to use const_cast.
CXX.Flags += -Wcast-qual

ifeq ($(HOST_OS),HP-UX)
  CompileCommonOpts := -D_REENTRANT -D_HPUX_SOURCE
endif

# If we are building a universal binary on Mac OS/X, pass extra options.  This
# is useful to people that want to link the LLVM libraries into their universal
# apps.
#
# The following can be optionally specified:
#   UNIVERSAL_SDK_PATH variable can be specified as a path to the SDK to use.
#      For Mac OS/X 10.4 Intel machines, the traditional one is:
#      UNIVERSAL_SDK_PATH=/Developer/SDKs/MacOSX10.4u.sdk/
#   UNIVERSAL_ARCH can be optionally specified to be a list of architectures
#      to build for, e.g. UNIVERSAL_ARCH="i386 ppc ppc64".  This defaults to
#      i386/ppc only.
ifdef UNIVERSAL
  ifndef UNIVERSAL_ARCH
    UNIVERSAL_ARCH := i386 ppc
  endif
  UNIVERSAL_ARCH_OPTIONS := $(UNIVERSAL_ARCH:%=-arch %)
  CompileCommonOpts += $(UNIVERSAL_ARCH_OPTIONS)
  ifdef UNIVERSAL_SDK_PATH
    CompileCommonOpts += -isysroot $(UNIVERSAL_SDK_PATH)
  endif

  # Building universal cannot compute dependencies automatically.
  DISABLE_AUTO_DEPENDENCIES=1
else
  ifeq ($(TARGET_OS),Darwin)
    ifeq ($(ARCH),x86_64)
      TargetCommonOpts = -m64
    else
      ifeq ($(ARCH),x86)
        TargetCommonOpts = -m32
      endif
    endif
  endif
endif

ifeq ($(HOST_OS),SunOS)
CPP.BaseFlags += -include llvm/Support/Solaris.h
endif

ifeq ($(HOST_OS),AuroraUX)
CPP.BaseFlags += -include llvm/Support/Solaris.h
endif # !HOST_OS - AuroraUX.

# On Windows, SharedLibDir != LibDir. The order is important.
ifeq ($(HOST_OS), $(filter $(HOST_OS), Cygwin MingW))
  LD.Flags    += -L$(SharedLibDir) -L$(LibDir) -L$(LLVMToolDir) -L$(LLVMLibDir)
else
  LD.Flags    += -L$(LibDir) -L$(LLVMLibDir)
endif

CPP.BaseFlags += -D_GNU_SOURCE -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS
# All -I flags should go here, so that they don't confuse llvm-config.
CPP.Flags     += $(sort -I$(PROJ_OBJ_DIR) -I$(PROJ_SRC_DIR) \
	         $(patsubst %,-I%/include,\
	         $(PROJ_OBJ_ROOT) $(PROJ_SRC_ROOT) \
	         $(LLVM_OBJ_ROOT) $(LLVM_SRC_ROOT))) \
	         $(CPP.BaseFlags)

ifeq ($(INCLUDE_BUILD_DIR),1)
  CPP.Flags   += -I$(ObjDir)
endif

# SHOW_DIAGNOSTICS support.
ifeq ($(SHOW_DIAGNOSTICS),1)
  Compile.Wrapper := env CC_LOG_DIAGNOSTICS=1 \
	                  CC_LOG_DIAGNOSTICS_FILE="$(LLVM_OBJ_ROOT)/$(BuildMode)/diags"
else
  Compile.Wrapper :=
endif

Compile.C     = $(Compile.Wrapper) \
	          $(CC) $(CPP.Flags) $(C.Flags) $(CFLAGS) $(CPPFLAGS) \
                $(TargetCommonOpts) $(CompileCommonOpts) -c
Compile.CXX   = $(Compile.Wrapper) \
	          $(CXX) $(CPP.Flags) $(CXX.Flags) $(CXXFLAGS) $(CPPFLAGS) \
                $(TargetCommonOpts) $(CompileCommonOpts) -c
Preprocess.CXX= $(Compile.Wrapper) \
	          $(CXX) $(CPP.Flags) $(TargetCommonOpts) $(CPPFLAGS) \
                $(CompileCommonOpts) $(CXX.Flags) -E
Link          = $(Compile.Wrapper) \
	          $(CXX) $(CPP.Flags) $(CXX.Flags) $(CXXFLAGS) $(LD.Flags) \
                $(LDFLAGS) $(TargetCommonOpts)  $(CompileCommonOpts) $(Strip)

BCCompile.C   = $(LLVMCC) $(CPP.Flags) $(C.Flags) $(CFLAGS) $(CPPFLAGS) \
                $(TargetCommonOpts) $(CompileCommonOpts)
Preprocess.C  = $(CC) $(CPP.Flags) $(C.Flags) $(CPPFLAGS) \
                $(TargetCommonOpts) $(CompileCommonOpts) -E

BCCompile.CXX = $(LLVMCXX) $(CPP.Flags) $(CXX.Flags) $(CXXFLAGS) $(CPPFLAGS) \
                $(TargetCommonOpts) $(CompileCommonOpts)

ProgInstall   = $(INSTALL) $(Install.StripFlag) -m 0755
ScriptInstall = $(INSTALL) -m 0755
DataInstall   = $(INSTALL) -m 0644

# When compiling under Mingw/Cygwin, the tblgen tool expects Windows
# paths. In this case, the SYSPATH function (defined in
# Makefile.config) transforms Unix paths into Windows paths.
TableGen.Flags= -I $(call SYSPATH, $(PROJ_SRC_DIR)) \
                -I $(call SYSPATH, $(LLVM_SRC_ROOT)/include) \
                -I $(call SYSPATH, $(PROJ_SRC_ROOT)/include) \
                -I $(call SYSPATH, $(PROJ_SRC_ROOT)/lib/Target)
LLVMTableGen  = $(LLVM_TBLGEN) $(TableGen.Flags)

Archive       = $(AR) $(AR.Flags)
LArchive      = $(LLVMToolDir)/llvm-ar rcsf
ifdef RANLIB
Ranlib        = $(RANLIB)
else
Ranlib        = ranlib
endif

AliasTool     = ln -s

#----------------------------------------------------------
# Get the list of source files and compute object file
# names from them.
#----------------------------------------------------------

ifndef SOURCES
  Sources := $(notdir $(wildcard $(PROJ_SRC_DIR)/*.cpp \
             $(PROJ_SRC_DIR)/*.cc $(PROJ_SRC_DIR)/*.c))
else
  Sources := $(SOURCES)
endif

ifdef BUILT_SOURCES
Sources += $(filter %.cpp %.c %.cc,$(BUILT_SOURCES))
endif

BaseNameSources := $(sort $(basename $(Sources)))

ObjectsO  := $(BaseNameSources:%=$(ObjDir)/%.o)
ObjectsBC := $(BaseNameSources:%=$(ObjDir)/%.bc)

#----------------------------------------------------------
# For Mingw MSYS bash and Python/w32:
#
# $(ECHOPATH) prints DOSish pathstring.
#   ex) $(ECHOPATH) /include/sys/types.h
#   --> C:/mingw/include/sys/types.h
# built-in "echo" does not transform path to DOSish path.
#
# FIXME: It would not be needed when MSYS's python
# were provided.
#----------------------------------------------------------

ifeq (-mingw32,$(findstring -mingw32,$(BUILD_TRIPLE)))
  ECHOPATH := $(Verb)python -u -c "import sys;print ' '.join(sys.argv[1:])"
else
  ECHOPATH := $(Verb)$(ECHO)
endif

###############################################################################
# DIRECTORIES: Handle recursive descent of directory structure
###############################################################################

#---------------------------------------------------------
# Provide rules to make install dirs. This must be early
# in the file so they get built before dependencies
#---------------------------------------------------------

$(DESTDIR)$(PROJ_bindir) $(DESTDIR)$(PROJ_libdir) $(DESTDIR)$(PROJ_includedir) $(DESTDIR)$(PROJ_etcdir)::
	$(Verb) $(MKDIR) $@

# To create other directories, as needed, and timestamp their creation
%/.dir:
	$(Verb) $(MKDIR) $* > /dev/null
	$(Verb) $(DOTDIR_TIMESTAMP_COMMAND) > $@

.PRECIOUS: $(ObjDir)/.dir $(LibDir)/.dir $(ToolDir)/.dir $(ExmplDir)/.dir
.PRECIOUS: $(LLVMLibDir)/.dir $(LLVMToolDir)/.dir $(LLVMExmplDir)/.dir

#---------------------------------------------------------
# Handle the CONFIG_FILES options
#---------------------------------------------------------
ifdef CONFIG_FILES

ifdef NO_INSTALL
install-local::
	$(Echo) Install circumvented with NO_INSTALL
uninstall-local::
	$(Echo) UnInstall circumvented with NO_INSTALL
else
install-local:: $(DESTDIR)$(PROJ_etcdir) $(CONFIG_FILES)
	$(Echo) Installing Configuration Files To $(DESTDIR)$(PROJ_etcdir)
	$(Verb)for file in $(CONFIG_FILES); do \
          if test -f $(PROJ_OBJ_DIR)/$${file} ; then \
            $(DataInstall) $(PROJ_OBJ_DIR)/$${file} $(DESTDIR)$(PROJ_etcdir) ; \
          elif test -f $(PROJ_SRC_DIR)/$${file} ; then \
            $(DataInstall) $(PROJ_SRC_DIR)/$${file} $(DESTDIR)$(PROJ_etcdir) ; \
          else \
            $(ECHO) Error: cannot find config file $${file}. ; \
          fi \
	done

uninstall-local::
	$(Echo) Uninstalling Configuration Files From $(DESTDIR)$(PROJ_etcdir)
	$(Verb)for file in $(CONFIG_FILES); do \
	  $(RM) -f $(DESTDIR)$(PROJ_etcdir)/$${file} ; \
	done
endif

endif

###############################################################################
# Set up variables for building libraries
###############################################################################

#---------------------------------------------------------
# Define various command line options pertaining to the
# libraries needed when linking. There are "Proj" libs
# (defined by the user's project) and "LLVM" libs (defined
# by the LLVM project).
#---------------------------------------------------------

ifdef USEDLIBS
ProjLibsOptions := $(patsubst %.a.o, -l%, $(addsuffix .o, $(USEDLIBS)))
ProjLibsOptions := $(patsubst %.o, $(LibDir)/%.o,  $(ProjLibsOptions))
ProjUsedLibs    := $(patsubst %.a.o, lib%.a, $(addsuffix .o, $(USEDLIBS)))
ProjLibsPaths   := $(addprefix $(LibDir)/,$(ProjUsedLibs))
endif

ifdef LLVMLIBS
LLVMLibsOptions := $(patsubst %.a.o, -l%, $(addsuffix .o, $(LLVMLIBS)))
LLVMLibsOptions := $(patsubst %.o, $(LLVMLibDir)/%.o, $(LLVMLibsOptions))
LLVMUsedLibs    := $(patsubst %.a.o, lib%.a, $(addsuffix .o, $(LLVMLIBS)))
LLVMLibsPaths   := $(addprefix $(LLVMLibDir)/,$(LLVMUsedLibs))
endif

# Loadable module for Win32 requires all symbols resolved for linking.
# Then all symbols in LLVM.dll will be available.
ifeq ($(ENABLE_SHARED),1)
  ifdef LOADABLE_MODULE
    ifneq (,$(filter $(HOST_OS),Cygwin MingW))
      LINK_COMPONENTS += all
    endif
  endif
endif

ifndef IS_CLEANING_TARGET
ifdef LINK_COMPONENTS

# If LLVM_CONFIG doesn't exist, build it.  This can happen if you do a make
# clean in tools, then do a make in tools (instead of at the top level).
$(LLVM_CONFIG):
	@echo "*** llvm-config doesn't exist - rebuilding it."
	@$(MAKE) -C $(PROJ_OBJ_ROOT)/tools/llvm-config

$(ToolDir)/$(strip $(TOOLNAME))$(EXEEXT): $(LLVM_CONFIG)

ifeq ($(ENABLE_SHARED), 1)
# We can take the "auto-import" feature to get rid of using dllimport.
ifeq ($(HOST_OS), $(filter $(HOST_OS), Cygwin MingW))
LLVMLibsOptions += -Wl,--enable-auto-import,--enable-runtime-pseudo-reloc \
                   -L $(SharedLibDir)
endif
LLVMLibsOptions += -lLLVM-$(LLVMVersion)
LLVMLibsPaths += $(SharedLibDir)/$(SharedPrefix)LLVM-$(LLVMVersion)$(SHLIBEXT)
else

ifndef NO_LLVM_CONFIG
LLVMConfigLibs := $(shell $(LLVM_CONFIG) --libs $(LINK_COMPONENTS) || echo Error)
ifeq ($(LLVMConfigLibs),Error)
$(error llvm-config --libs failed)
endif
LLVMLibsOptions += $(LLVMConfigLibs)
LLVMConfigLibfiles := $(shell $(LLVM_CONFIG) --libfiles $(LINK_COMPONENTS) || echo Error)
ifeq ($(LLVMConfigLibfiles),Error)
$(error llvm-config --libfiles failed)
endif
LLVMLibsPaths += $(LLVM_CONFIG) $(LLVMConfigLibfiles)
endif

endif
endif
endif

# Set up the library exports file.
ifdef EXPORTED_SYMBOL_FILE

# First, set up the native export file, which may differ from the source
# export file.

ifeq ($(HOST_OS),Darwin)
# Darwin convention prefixes symbols with underscores.
NativeExportsFile := $(ObjDir)/$(notdir $(EXPORTED_SYMBOL_FILE)).sed
$(NativeExportsFile): $(EXPORTED_SYMBOL_FILE) $(ObjDir)/.dir
	$(Verb) sed -e 's/^/_/' < $< > $@
clean-local::
	-$(Verb) $(RM) -f $(NativeExportsFile)
else
ifeq ($(HAVE_LINK_VERSION_SCRIPT),1)
# Gold and BFD ld require a version script rather than a plain list.
NativeExportsFile := $(ObjDir)/$(notdir $(EXPORTED_SYMBOL_FILE)).map
$(NativeExportsFile): $(EXPORTED_SYMBOL_FILE) $(ObjDir)/.dir
	$(Verb) echo "{" > $@
	$(Verb) grep -q '[[:alnum:]_]' $< && echo "  global:" >> $@ || :
	$(Verb) sed -e 's/$$/;/' -e 's/^/    /' < $< >> $@
ifneq ($(HOST_OS),OpenBSD)
	$(Verb) echo "  local: *;" >> $@
endif
	$(Verb) echo "};" >> $@
clean-local::
	-$(Verb) $(RM) -f $(NativeExportsFile)
else
ifeq ($(HOST_OS), $(filter $(HOST_OS), Cygwin MingW))
# GNU ld Win32 accepts .DEF files that contain "DATA" entries.
NativeExportsFile := $(ObjDir)/$(notdir $(EXPORTED_SYMBOL_FILE:.exports=.def))
$(NativeExportsFile): $(EXPORTED_SYMBOL_FILE) $(ObjDir)/.dir
	$(Echo) Generating $(notdir $@)
	$(Verb) $(ECHO) "EXPORTS" > $@
	$(Verb) $(CAT) $< >> $@
clean-local::
	-$(Verb) $(RM) -f $(NativeExportsFile)
else
# Default behavior: just use the exports file verbatim.
NativeExportsFile := $(EXPORTED_SYMBOL_FILE)
endif
endif
endif

# Now add the linker command-line options to use the native export file.

# Darwin
ifeq ($(HOST_OS),Darwin)
LLVMLibsOptions += -Wl,-exported_symbols_list,$(NativeExportsFile)
endif

# gold, bfd ld, etc.
ifeq ($(HAVE_LINK_VERSION_SCRIPT),1)
LLVMLibsOptions += -Wl,--version-script,$(NativeExportsFile)
endif

# Windows
ifeq ($(HOST_OS), $(filter $(HOST_OS), Cygwin MingW))
# LLVMLibsOptions is invalidated at processing tools/llvm-shlib.
SharedLinkOptions += $(NativeExportsFile)
endif

endif

###############################################################################
# OTHER RULES: Other rules needed
###############################################################################

# Define clean-local to clean the current directory. Note that this uses a
# very conservative approach ensuring that empty variables do not cause
# errors or disastrous removal.
clean-local::
ifneq ($(strip $(ObjRootDir)),)
	-$(Verb) $(RM) -rf $(ObjRootDir)
endif
ifneq ($(strip $(SHLIBEXT)),) # Extra paranoia - make real sure SHLIBEXT is set
	-$(Verb) $(RM) -f *$(SHLIBEXT)
endif

clean-all-local::
	-$(Verb) $(RM) -rf Debug Release Profile


